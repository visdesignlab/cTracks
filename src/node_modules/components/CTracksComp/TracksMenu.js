import React from 'react'
import hamradio from 'hamradio'
import {CompactPicker} from 'react-color'
import _ from 'lodash'

import LabelLayout from './basicComponents/LabelLayout'
import FlexRow from './basicComponents/FlexRow'
import Selector from './basicComponents/Selector'
import IconButton from './basicComponents/IconButton'
import TextButton from './basicComponents/TextButton'

import viewconfig from './utils/viewconfig'
import tracks from './utils/tracks'

import './TracksMenu.css'


class TracksMenu extends React.Component {
  constructor (props) {
    super(props);

    this.subscriptions = this.makeSubscriptions()

    this.state = {
      editTrack: null,
      editRow: null,
      editConstant: this.blankConstant(),
      valueScaleMax: undefined,
      valueScaleMin: undefined
    }
	}

  componentWillUnmount() {
    this.subscriptions.forEach(sub => sub.unsubscribe())
  }

  makeSubscriptions() {
    return [
      hamradio.subscribe(
        'track/modify',
        (name, row) => {
          if (this.state.editTrack && this.state.editTrack.uid in row.tilesets) {
            this.setState({editTrack: row.tilesets[this.state.editTrack.uid]})
          }
        }
      ),
      hamradio.subscribe(
        'track/remove',
        (name, track) => {
          if (this.state.editTrack && track.uid === this.state.editTrack.uid) {
            this.setState({editTrack: null, editRow: null})
          }
        }
      )
    ]
  }

  trackName = (row, track) => {
    let tilesetName = track.options.name || track.uid
    return `Row ${row.row}: ${tilesetName}`
  }

  toggleVisibility = (row, global, focus) => {
    hamradio.publish('track/modify', {...row, global, focus})
  }

  editTrack = (row, track) => {
    this.setState({
      editTrack: _.cloneDeep(track),
      editRow: _.cloneDeep(row),
      valueScaleMax: track ? track.options.valueScaleMax : undefined,
      valueScaleMin: track ? track.options.valueScaleMin : undefined
    })
  }

  removeTrack = (row, track) => {
    hamradio.publish('track/remove', {row: row.row, uid: track.uid})
  }

  setTrackValue = (key, value) => {
    const track = _.merge({}, this.state.editTrack, {[key]: value})
    const row = _.merge({}, this.state.editRow, {tilesets: {[this.state.editTrack.uid]: track}})
    hamradio.publish('track/modify', row)
  }

  setOptionValue = (option, value) => {
    const track = _.merge({}, this.state.editTrack, {options: {[option]: value}})
    const row = _.merge({}, this.state.editRow, {tilesets: {[this.state.editTrack.uid]: track}})
    if (value === undefined) { // override lodash's behavior of ignoring undefined values
      row.tilesets[this.state.editTrack.uid].options[option] = undefined
    }
    hamradio.publish('track/modify', row)
  }

  setPrimaryColor = (color) => {
    let options = tracks.options[this.state.editTrack.type]({}, color)
    const track = _.merge({}, this.state.editTrack, {options})
    const row = _.merge({}, this.state.editRow, {tilesets: {[this.state.editTrack.uid]: track}})
    hamradio.publish('track/modify', row)
  }

  blankConstant = () => {
    return {
      color: '#555555',
      opacity: 1.0,
      label: '',
      labelPosition: 'right',
      labelColor: '#555555',
      LabelOpacity: 1.0,
      value: 1
    }
  }

  addConstant = () => {
    let options = _.cloneDeep(this.state.editTrack.options)
    if (options.constIndicators) {
      options.constIndicators.push(this.state.editConstant)
    } else {
      options.constIndicators = [this.state.editConstant]
    }
    const track = _.merge({}, this.state.editTrack, {options})
    const row = _.merge({}, this.state.editRow, {tilesets: {[this.state.editTrack.uid]: track}})
    hamradio.publish('track/modify', row)
    this.setState({editConstant: this.blankConstant()})
  }

  removeConstant = (index) => {
    let options = _.cloneDeep(this.state.editTrack.options)
    options.constIndicators.splice(index, 1)
    const track = tracks.merge(this.state.editTrack, {options})
    const row = tracks.merge(this.state.editRow, {tilesets: {[this.state.editTrack.uid]: track}})
    hamradio.publish('track/modify', row)
    this.setState({editConstant: this.blankConstant()})
  }

  changeType = (type) => {
    let primaryColor = tracks.getPrimaryColor(this.state.editTrack)
    let options = tracks.options[type]({}, primaryColor)
    const track = _.merge({}, this.state.editTrack, {type, options})
    const row = _.merge({}, this.state.editRow, {tilesets: {[this.state.editTrack.uid]: track}})
    hamradio.publish('track/remove', {row: this.state.editRow.row, uid: this.state.editTrack.uid})
    hamradio.publish('track/add', row)
  }

  trackOverview = () => {
    return (
      <div>
  			<label>Tracks</label>
        {viewconfig.sortTracks(Object.values(this.props.tracks)).map(row => (
          <div key={row.row}>
            <LabelLayout label={`Row ${row.row}`}
              inner=<div>
                <TextButton
                  onClick={() => this.toggleVisibility(row, !row.global, row.focus)}
                  text="Global"
                  backgroundColor={row.global ? 'black' : 'white'}
                  color={row.global ? 'white' : 'grey'}
                />
                <TextButton
                  onClick={() => this.toggleVisibility(row, row.global, !row.focus)}
                  text="Focus"
                  backgroundColor={row.focus ? 'black' : 'white'}
                  color={row.focus ? 'white' : 'grey'}
                />
              </div>
            />
            <ul>
              {Object.values(row.tilesets).map(tileset => (
                <li key={tileset.uid}>
                  <IconButton icon="eye" backgroundColor={tracks.getPrimaryColor(tileset)} color="white" onClick={() => this.editTrack(row, tileset)}/>
                  {this.props.allowDeletion
                    ? <IconButton icon="trash" backgroundColor={tracks.getPrimaryColor(tileset)} color="white" onClick={() => this.removeTrack(row, tileset)}/>
                    : null
                  }
                  <label>{tileset.options.name || tileset.uid}</label>
                </li>
              ))}
            </ul>
          </div>
        ))}
      </div>
		)
  }

  trackTypeBlock = () => {
    return (
      <LabelLayout label="Track Type"
        inner=<div>
          <Selector
            value={{value: this.state.editTrack.type, label: this.state.editTrack.type}}
            onChange={option => this.changeType(option.value)}
            options={tracks.trackDataTypes[this.state.editTrack.datatype]
              .concat(this.state.editTrack.filetype === 'bigwig' ? ['range'] : [])
              .map(type => ({value: type, label: type}))}
          />
        </div>
      />
    )
  }

  primaryColorBlock = () => {
    return (
      <div>
        <label>Primary Color</label>
        <div className="ColorPicker">
          <CompactPicker color={tracks.getPrimaryColor(this.state.editTrack)} onChange={color => this.setPrimaryColor(color.hex)}/>
        </div>
      </div>
    )
  }

  rangeResolutionBlock = () => {
    return (
      <div>
        <LabelLayout label="Resolution"
          inner=<input type="number" name="resolution" min="1" max="10"
            value={this.state.editTrack.options.resolution || 1} onChange={e => this.setOptionValue('resolution', e.target.value)}
          />
        />
        <LabelLayout label="Display as"
          inner=<div>
            <Selector
              value={{value: this.state.editTrack.options.mode, label: this.state.editTrack.options.mode}}
              onChange={option => this.setOptionValue('mode', option.value)}
              options={[
                {value: 'minMax', label: 'minMax'},
                {value: 'whisker', label: 'whisker'}
              ]}
            />
          </div>
        />
      </div>
    )
  }

  constantBlock = () => {
    return (
      <div>
        <label>Constants</label>
        <ul>
          {this.state.editTrack.options.constIndicators
            ? this.state.editTrack.options.constIndicators.map((ruler, index) => (
              <li key={index}>
                <LabelLayout label={`${ruler.label}: ${ruler.value}`}
                  inner=<IconButton onClick={() => this.removeConstant(index)} icon="minus"/>
                />
              </li>
            ))
            : null
          }
          <li>
            <FlexRow inner={[
              (<label key="llabel">Label:</label>),
              (<input key="ilabel" type="text" name="constant-label" style={{maxWidth:80}}
                value={this.state.editConstant.label} onChange={e => this.setState({editConstant: {...this.state.editConstant, label: e.target.value}})}
              />),
              (<label key="lvalue">Value:</label>),
              (<input key="ivalue" type="number" name="constant-value" style={{maxWidth:80}}
                value={this.state.editConstant.value} onChange={e => this.setState({editConstant: {...this.state.editConstant, value: e.target.value}})}
              />),
              (<IconButton key="accept" onClick={() => this.addConstant()} icon="plus" backgroundColor="black" color="white"/>)
            ]}/>
          </li>
        </ul>
      </div>
    )
  }

  yBoundsBlock = () => {
    let debouncedOptions = _.debounce(this.setOptionValue, 500, {trailing: true})
    let update = (option, value) => {
      debouncedOptions(option, value)
      this.setState({[option]: value})
    }
    let toggleAuto = (option) => {
      return () => {
        if (this.state[option] === undefined) {
          this.setOptionValue(option, 0.0)
          this.setState({[option]: 0.0})
        } else {
          this.setOptionValue(option, undefined)
          this.setState({[option]: undefined})
        }
      }
    }
    return (
      <div>
        <label>Y-Axis Bounds</label>
        <ul>
          <li>
            <FlexRow label="Max"
              inner={[
                <label>Max</label>,
                <TextButton text={this.state.valueScaleMax === undefined ? "Auto" : "Manual"}
                  onClick={toggleAuto('valueScaleMax')}
                  backgroundColor={this.state.valueScaleMax === undefined ? 'black' : 'white'}
                  color={this.state.valueScaleMax === undefined ? 'white' : 'black'}
                />,
                this.state.valueScaleMax === undefined ? null :
                  <input type="number" name="maxY" value={this.state.valueScaleMax}
                    onChange={e => update('valueScaleMax', e.target.value)} />
              ]}
            />
          </li>
          <li>
            <FlexRow
              inner={[
                <label>Min</label>,
                <TextButton text={this.state.valueScaleMin === undefined ? "Auto" : "Manual"}
                  onClick={toggleAuto('valueScaleMin')}
                  backgroundColor={this.state.valueScaleMin === undefined ? 'black' : 'white'}
                  color={this.state.valueScaleMin === undefined ? 'white' : 'black'}
                />,
                this.state.valueScaleMin === undefined ? null :
                  <input type="number" name="maxY" value={this.state.valueScaleMin}
                    onChange={e => update('valueScaleMin', e.target.value)} />
              ]}
            />
          </li>
        </ul>
      </div>
    )
  }

  trackEdit = () => {
    return (
      <div>
  			<label>Edit {this.trackName(this.state.editRow, this.state.editTrack)}</label>
        <div>
          <br/>
          {this.trackTypeBlock()}
          <br/>
          {this.primaryColorBlock()}
          {this.state.editTrack.type === 'range' ? (<br/>) : null}
          {this.state.editTrack.type === 'range' ? this.rangeResolutionBlock() : null}
          <br/>
          {this.constantBlock()}
          <br/>
          {this.yBoundsBlock()}
          <br/>
          <TextButton onClick={() => this.editTrack(null, null)} text="Done" />
        </div>
      </div>
    )
  }

	render () {
		return !this.state.editTrack ? this.trackOverview() : this.trackEdit()
	}
}


export default TracksMenu;
